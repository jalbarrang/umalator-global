---
globs: *.tsx
alwaysApply: false
---
# React Development Guide

## Core Principles

**Components must be pure**: Always return the same output for the same inputs (props, state, context)
**Hooks only at top level**: Never call hooks inside loops, conditions, or nested functions
**Components in JSX only**: Never call components as functions - use `<Component />` not `Component()`

## TypeScript with React

**Define prop types with interfaces**:

```tsx
interface ButtonProps {
  title: string;
  disabled?: boolean;
  onClick: () => void;
  children?: React.ReactNode;
}

function Button({ title, disabled = false, onClick, children }: ButtonProps) {
  return (
    <button disabled={disabled} onClick={onClick}>
      {title}
      {children}
    </button>
  );
}
```

## Essential Hooks

**useState**: Manage component state

```tsx
const [count, setCount] = useState(0);
const [user, setUser] = useState<User | null>(null);
```

**useEffect**: Synchronize with external systems (side effects)

```tsx
useEffect(() => {
  const connection = createConnection(serverUrl, roomId);
  connection.connect();

  // Cleanup function runs on unmount or before next effect
  return () => {
    connection.disconnect();
  };
}, [serverUrl, roomId]); // Dependencies array
```

**useRef**: Access DOM elements or persist mutable values

```tsx
const inputRef = useRef<HTMLInputElement>(null);
const countRef = useRef(0); // Doesn't trigger re-render

useEffect(() => {
  inputRef.current?.focus();
}, []);
```

**useMemo**: Cache expensive calculations

```tsx
const sortedItems = useMemo(() => {
  return items.sort((a, b) => a.price - b.price);
}, [items]); // Only recalculates when items change
```

**useCallback**: Memoize function references

```tsx
const handleSubmit = useCallback(
  (data: FormData) => {
    post('/api/submit', { userId, data });
  },
  [userId],
); // Only creates new function when userId changes
```

## Data Fetching Pattern

**Extract to custom hooks with proper cleanup**:

```tsx
function useData<T>(url: string) {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    let ignore = false;

    fetch(url)
      .then((res) => res.json())
      .then((json) => {
        if (!ignore) {
          setData(json);
          setLoading(false);
        }
      })
      .catch((err) => {
        if (!ignore) {
          setError(err);
          setLoading(false);
        }
      });

    return () => {
      ignore = true;
    }; // Prevent race conditions
  }, [url]);

  return { data, loading, error };
}

// Usage
function UserProfile({ userId }: { userId: string }) {
  const { data: user, loading, error } = useData<User>(`/api/users/${userId}`);

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  return <div>{user?.name}</div>;
}
```

## Common Patterns

**Conditional rendering**:

```tsx
// Using if/else
if (isPacked) return <li>{name} ✅</li>;
return <li>{name}</li>;

// Using ternary
return <li>{isPacked ? <del>{name} ✅</del> : name}</li>;

// Using && for optional rendering
return <div>{error && <ErrorMessage error={error} />}</div>;
```

**Rendering lists** (always include `key`):

```tsx
const items = products.map((product) => (
  <li key={product.id} style={{ color: product.inStock ? 'green' : 'red' }}>
    {product.name}
  </li>
));
```

**Event handling**:

```tsx
function Form() {
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    // Handle form submission
  };

  return (
    <form onSubmit={handleSubmit}>
      <input onChange={(e) => setValue(e.target.value)} />
    </form>
  );
}
```

## Performance Optimization

1. **Use `useMemo`** for expensive calculations
2. **Use `useCallback`** when passing callbacks to optimized child components
3. **Extract static content** outside components to avoid recreation
4. **Split large components** into smaller, focused ones
5. **Use keys properly** in lists - never use array indices for dynamic lists

## Best Practices

- Keep components small and focused on a single responsibility
- Extract reusable logic into custom hooks
- Use TypeScript interfaces for all prop types
- Always include cleanup in `useEffect` when needed
- Define components at module level, not inside other components
- Use meaningful component and prop names
- Avoid premature optimization - measure first
